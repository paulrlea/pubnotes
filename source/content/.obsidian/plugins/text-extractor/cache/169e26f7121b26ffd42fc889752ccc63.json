{"path":"Notes/@Summer2024/Computing for Physicists/In Class 5/CFP_lec5_2024.pdf","text":"Lecture 5: Randomness ◦Random numbers, probability distributions, and histograms ◦Stochastic processes Random numbers ◦Pseudo-randomness and seeds Random numbers are uncorrelated (cannot guess the next number knowing the previous numbers) Typically random numbers generated on a computer are not truly random (needs special hardware). Algorithms are deterministic in nature, same starting point  same results python defaults to seeding off of system time. ◦Probability distribution from which random numbers are selected ◦Uniform, Gaussian, etc. Uniform Distribution(every number in the range is equally probable). Selecting from uniformdistribution in range [0,1): np.random.rand() returns random number np.random.rand(N) returns array of N random numbers Histograms show the number of times a value was obtained. Probability distribution np.random can sample from many different distributions … density=‘true’ will normalize histogram so it is directly comparable to the probability distribution Stochastic processes They posses inherent randomness (examples include radioactive decay, diffusion, magnetic domain orientation, many statistical mechanics problems) How do we describe such processes? Radioactive decay ◦Spontaneous decay is a natural process in which a particle, with no external stimulation, and at one instant in time, decays into other particles ◦Since the exact moment when any one particle decays is random, it does not matter how long the particle has been around or what is happening with other particles. (independent events) Probability of decay Lets say in 1 second, a particle has a 1% chance of decaying. 𝑑𝑁 𝑑𝑡 = −.01 ∗𝑁 ∫𝑑𝑁/𝑁= ∫ − .01 ∗𝑑𝑡 ln𝑁 = −.01𝑡+𝐶 𝑁=𝑁𝑒. analytic route Start with initial number of particles 𝑁 Loop over total time (with a time step of 1 sec): for each particle roll some dice (1% of the time, destroy particle) (we assume that 1% of our particles disappear each second). This really only makes sense if we are talking about a large number of particles numerical route Start with initial number of particles N Loop over total time (with a time step of 1 second): Loop over every remaining particle: for each particle roll some dice (1% of the time, destroy that particle) exponential stochastic Simple Monte-Carlo type calculationDiffusion (random walk) Brownian motion: Pollen undergoes erratic motion when in a fluid. This is due to the instantaneous imbalance of net forces arising from collisions with the environment. Often modeled as a random walk (note this can be modeled with a random force taken from a Gaussian distribution) 2D Random Walk ◦Each step is the same length d ◦Each step is in a random direction  𝜃= random number [0,2𝜋). After N steps, ◦𝑥= Δ𝑥+ Δ𝑥+ ⋯ + Δ𝑥 =∑ cos𝜃𝑑 ◦𝑦= Δ𝑦+ Δ𝑦+ ⋯ + Δ𝑦 =∑ sin𝜃𝑑 𝜃 Δ𝑥 Δ𝑦 Every realization of the walk is different. What useful information can be extracted? Note: cumsum = cumulative sum dx.cumsum() returns array: [ dx[0], dx[0]+dx[1], dx[0]+dx[1]+dx[2],…] subplots fig, ax = plt.subplots(nrows=2, ncols=2) creates a 2D-array ax of subplots. ax[0,0], ax[0,1], ax[1,0], and ax[1,1] To show 4 instances of a 2D random walk, we could use the following Need to do many walks for decent statistics proper aspect ratio is important, otherwise results can be misleading final positions of 10,000 walks (each of 1000 steps) 2D histogram 104walks 105walks 106walks Looking at x and y values statistics: The final x and y positions after a random walk follow a Gaussian distribution. 68% of trajectories fall within ±𝜎 95% within ±2𝜎 𝜎≈ 22.3 How does number of steps effect result? root mean square distance: <𝑅>= <𝑥+𝑦> (brackets indicate average) 10 run average 100 run average 1000 run average 10000 run average <𝑅>=𝑑 𝑁 Note on 1D walks can avoid effects from even/odd number of steps by choosing bins of width 2. Activity (lecture 5) 1D random walk (equal probability of going left or right) 1)Construct the probability distribution (histogram) associated with the final position after a 5000 step walk. 2)Generate a plot of the RMS position <𝑅>as a function of 𝑁.","libVersion":"0.5.0","langs":""}