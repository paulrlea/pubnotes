{"path":"Notes/Physics/Computational Physics/Briefing.pdf","text":"PHAS0030 Mini-project briefing PHAS0030: Computational Physics Mini-project briefing: complex orbital dynamics David Bowler, Andreas Korn The precise solution of the orbital motion of bodies under the in- fluence of gravity is an important and challenging problem. This project will consider realistic problems (models of the solar system) and idealised problems (complex orbits for bodies of the same mass), with the stability both of different physical situations and of different propagation methods being considered. After a guided introduction, you will have freedom to choose a research direction, and will apply the computational physics skills you have learned during the course to investigate these important problems. Contents 1 Objectives 1 2 Introduction 2 3 Preliminary investigation 2 3.1 Integrators: background information 3 3.2 A first test: two bodies, different masses 4 3.3 Two bodies, similar masses 5 3.4 Three bodies 5 3.5 A different integrator 6 4 Progress check 7 5 Extensions 8 5.1 Solar system dynamics 8 5.2 N-body choreographies 9 6 Advice and suggestions 10 7 Submission 11 1 Objectives The objectives of this project are to: • Investigate simple problems with two bodies moving under the influence of gravity (both with equal masses and with different masses) • Extend this simulation to systems of several bodies (idealised and/or realistic) and perform independent research on this prob- lem • Explore the stability and accuracy of different solution methods for the differential equations, and the effect of initial conditions 1 PHAS0030 Mini-project briefing • Gain experience in performing independent research • Demonstrate your skills in using computational physics for a practical problem • Show that you can write a formal report documenting the results of your project 2 Introduction The gravitational force on a mass, m1, at a point r1 due to another mass, m2, located at a point r2, is given by: F12 = Gm1m2 | r12 |3 r12 (1) where r12 = r2 − r1. From this simple force, we can find complex behaviours that are still being researched today (as seen in the references). Note that analytic solutions cannot be found for more than two bodies: all solutions to more complex problems must be numerical. Systems of the kind to be studied in this project should conserve energy, and monitoring this is a key way to characterise the stability of a numerical method. The gravitational potential energy for a group of bodies with masses mi is given by: U = ∑ i ∑ j>i − Gmimj | rij | (2) where the sum over j is chosen to avoid double counting of terms. The kinetic energy is the usual form, ∑i 1 2 miv2 i . Angular momen- tum should also be conserved, and is easily calculated for simple systems. The total force on a single body with mass mi from all other bodies in the system is: Fi = ∑ j̸=i Gmimj | rij |3 rij (3) where rij = rj − ri. 3 Preliminary investigation This section includes topics that you must address in your final re- port, while the later sections offer suggestions of what you might want to consider to extend your investigation, but do not require anything specific. You should aim to do most of the work in this section before reading week, so that you can get help on any prob- lems that you are having (note that the Week 4 assignment forms the first part of this work). The basic techniques you will imple- ment here will form the basis of all the work in your mini-project, so ensure that you are confident in what you are doing. We will 2 PHAS0030 Mini-project briefing work in a set of units (which I will not define explicitly) which have G=1, for simplicity. By the end of this preliminary work, you should have successfully implemented orbital dynamics for two and three body systems, and characterised the stability of two dif- ferent techniques. 3.1 Integrators: background information The simplest integrator that we will use is Euler’s method, which is described in full detail in the Week 4 notes. If we have a function f (t) and its time derivative, d f /dt, then we can advance it in time by a small amount, dt, using the following approach: f (t + dt) = f (t) + dt d f dt (4) This way, we can calculate the value of the function from a known starting point, f (t0), at a set of times f (t1), f (t2), . . . where t1 = t0 + dt, t2 = t1 + dt = t0 + 2dt, . . . etc. More specifically, we can calculate the position ri and velocity vi for a body i with mass mi using this method with the equations dri/dt = vi, dvi/dt = Fi/mi, where we have calculated the acceleration from the force acting on the body. A simple implementation of the Euler method in a 1D system might look like this (assuming the existence of a Python function dfdt(f,t)): # Parameters N = 1000 dt = 0.01 # Storage t = np.linspace(0,N*dt,N+1) f = np.zeros(N+1) # Initialise and propagate f[0] = 0.0 for i in range(N): f[i+1] = f[i] + dt*dfdt(f[i],t[i]) However, as we have seen in Week 4, the Euler method is inher- ently unstable, and requires a small timestep for accuracy; even with a small timestep, instabilities often occur at long times. A more stable and accurate method, which is often used when mod- elling systems of particles, is the velocity Verlet method, which will be formally introduced in Week 7. It conserves energy, and is time reversible (it is one of a class of methods known as symplec- tic methods). The equations are a little more complicated than for Euler’s method, and require a calculation of the force at time t + dt before the velocity at t + dt can be found: ri(t + dt) = ri(t) + dtvi(t) + 1 2 dt2 Fi(t) mi (5) vi(t + dt) = vi(t) + 1 2 dt ( Fi(t) + Fi(t + dt) mi ) (6) 3 PHAS0030 Mini-project briefing A simple implementation of the velocity Verlet method for a 2D system with one particle, assuming that a Python force function force(r) has been defined elsewhere, might be: # Parameters N=1000 dt = 0.01 m = 0.0001 # Storage t = np.linspace(0,N*dt,N+1) r = np.zeros((N+1,2)) # N+1 timesteps, 2 components v = np.zeros((N+1,2)) # Initial conditions r[0] = np.array((1.0,0.0)) v[0] = np.array((0.0,1.0)) # Propagate for i in range(N): # Force at step i fi = force(r[i]) # Position at step i+1 r[i+1] = r[i] + dt*v[i] + 0.5*dt*dt*fi/m # Force at step i+1, using new position fi_plus_1 = force(r[i+1]) # Velocity at step i+1 v[i+1] = v[i] + 0.5*dt*(fi + fi_plus_1)/m Note that the choices for number of steps, timestep, mass, and initial conditions in the two examples above are entirely arbitrary, and you should be sure to use the correct values for your simula- tion. The velocity Verlet method is accurate to second order in the timestep (errors are proportional to dt2), while the Euler method is only accurate to first order in the timestep. There are methods which are higher order in timestep, such as the Runge-Kutta meth- ods, but these often are neither time-reversible nor energy conserv- ing. We have discussed the most common of these, the fourth order RK4 method, in Week 4, where we created a function to imple- ment this method; it is also possible to use a function from SciPy, integrate.solve_ivp, though this requires careful setting up, and will be discussed in detail below. But in orbital dynamics, energy conservation and time reversibility is often more important than the higher accuracy (and hence longer timesteps) that come from higher order methods. 3.2 A first test: two bodies, different masses This task, and the next, form the (unmarked) assessment for Week 4 of the course, but you should include the work as part of the mini-project. Here, we will consider a system like a moon orbiting a planet, or a planet orbiting a star. You should start with a large 4 PHAS0030 Mini-project briefing mass ratio (at least 1,000:1), setting G = 1 and m1 = 1 for the large body, and use Euler’s method (even though we know that it will not be a good approach). We will assume that the large body does not move, so put it at the origin, and do not update its position; put the small mass at r2 = 1. You should be able to work out the initial velocity for the small mass to move in a circular orbit around the large one using simple mechanics (the equation to solve is m2v2 2/r2 = Gm1m2/r2 12 but you should be able to figure out and then explain where this comes from). You should then propagate the system forward in time for at least two orbits, recording the position and velocity at each timestep. Make appropriate plots of the trajectory. You can ex- periment with the timestep to find one that allows reasonable per- formance. You should also calculate the total energy at each step (kinetic and potential) either during the propagation or afterwards, and find the magnitude of the angular momentum at each step. Plot both of these, and check how well they are conserved, particu- larly with timestep size. Discuss your findings. 3.3 Two bodies, similar masses This task is also part of the Week 4 assessment, but should be docu- mented. You will consider two bodies with similar masses (no more than a 1:10 ratio between them) moving about their centre of mass, which is formally defined as: rCoM = m1r1 + m2r2 m1 + m2 (7) The equations are much simpler if you put the centre of mass at the origin (rCoM = 0). Setting the distance between the bodies r12 = 1 and starting the bodies on the x-axis initially, it is easy to find the initial positions, while simple classical mechanics gives appropriate initial velocities for circular orbits around the centre of mass (similarly to the case above, for body 1, you need to solve m1v2 1/r1 = Gm1m2/r2 12). Propagate the system forward in time using the velocity Verlet method, ensuring that you cover several periods of the orbit, and plot the orbits appropriately. Calculate the energy and angular momentum as before (though in this case you will need to add the energy and angular momentum for both bodies), and discuss their conservation. How do the Euler and velocity Verlet methods compare? You might like to examine the effect of the timestep on the orbits and the conservation laws. 3.4 Three bodies We now extend the initial part of the project by going beyond the initial week 4 assignment; this is still a required part of the project, however. We will consider a three body problem, which is a more chal- lenging problem to initialise and propagate. We will use a sys- 5 PHAS0030 Mini-project briefing tem with a star, a planet and a moon, with masses m1 = 1, m2 = 3 × 10−6 and m3 = 3.6 × 10−8 (again with G=1). We will set r12 = 1 and r23 = 0.0025. You should start the bodies aligned along an axis, choose a suitable origin and calculate appropriate initial velocities. A simple approximation would be to set v1 = 0, and find v2 in the usual way, ignoring the influence of m3; you can then find the velocity of m3 relative to m2 by considering the orbit of m3 about m2 (ignoring the influence of m1) and then adding v2 to v3 to get an initial value for v3 (you should check that you understand how I have arrived at these approximations, and that you can explain them for yourself—they are all based on simple orbital mechanics). A more accurate approximation, but one which is a little harder to work out, would be to consider the orbit of a combined mass m23 = m2 + m3 about m1 (the combined m23 will be located at the centre of mass of m2 and m3, and m1 and m23 will orbit the centre of mass of the entire system) and then consider the orbit of m2 and m3 about their centre of mass. Explain which choice you have made, and give the background maths. Propagate your system forward for at least two orbits of m2 about m1 using velocity Verlet, and consider how to plot the dy- namics of all three bodies. You should also carefully consider the appropriate conservation laws, and demonstrate how well they are obeyed. 3.5 A different integrator The final task in the first part of the mini-project is to evolve one of the systems you have already examined in Sections 3.2—3.4 using a higher order integrator (e.g. the fourth order Runge-Kutta integra- tor). You should choose a system that you are confident in working with, and can use either the Runge-Kutta code from the exercises (please make sure that you reference this appropriately) or you can call the function integrate.solve_ivp after importing the appro- priate SciPy module (from scipy import integrate). The main challenge with using the SciPy function that I found was writing the function to pass to the integrator (the right hand side); this just requires a little care with the array that you pass which will include vector positions and velocities for all bodies that you are consider- ing. Remember also that you can pass an array of times at which you want the solution evaluated (which can help make good plots). You should choose a combination you are confident with (the first task in Section 3.2, with the version of Runge-Kutta you wrote in class, should be relatively straightforward, while the other tasks or the SciPy integrator may be more challenging). You could examine how well energy and angular momentum are conserved with the integrator, and perhaps its stability with timestep. Let’s consider the arrays in a little more detail. The SciPy func- tion requires a 1D input for y0 (the initial conditions); if you choose to do one particle in 2 dimensions (the problem in Sec. 3.2 where 6 PHAS0030 Mini-project briefing we fix the central body) then you will need an array with four com- ponents (position and velocity in two dimensions each). For two bodies, both moving in two dimensions (the problem in Sec. 3.3) you will need an array with eight components (position and ve- locity in two dimensions for each body). You can pack these in any order you choose (though it should be logical to help others read the code). Your right-hand side function will need to unpack this input vector, calculate the appropriate derivatives, and pack them into an output vector of the same shape, with the same or- der. (To unpack, you can do something like r1 = y[0:Ndim] to put an Ndim-dimensional vector into r1, which can be passed to your force routine, and the reverse to create the output vec- tor.) The final output from the SciPy function is ordered by com- ponent, and then timestep (so that if you call it with result = integrate.solve_ivp(...) then result.y[0] contains an array of the first component at all timesteps). For your own routine (e.g. using the code from Week 4, which should be properly referenced if used) you are free to choose what- ever array shape you find best. You could use a one dimensional array as SciPy does, or you could have an input array with shape y0 = np.zeros((Npart,2,Ndim)) for Npart bodies (we have two components for position and velocity, each of which has Ndim di- mensions). This can get a little cumbersome when adding a time dimension as well! But feel free to use whatever you find easiest. 4 Progress check At this stage, you should now have written code which propagates the motion of two bodies over time, using both the Euler and the velocity Verlet methods (though note that you should not use the Euler method after this point—check that you understand why) as part of the Week 4 assessment. You should also have studied a simple three-body system, and a Runge-Kutta integrator for one of these early systems. (The Runge-Kutta integrator is the least important of these tasks, so if you are struggling to make it work, you would be better advised to work on the extensions in the next section.) This basic approach to orbital dynamics should serve you for the rest of the project, so ensure that you are completely clear in what you are doing: it will become more complicated as you add more bodies to the simulation. You should also have some discussion of the different approaches and their accuracy, particularly in relation to conservation of quantities and effect of initial conditions. All this work, both coding and writing, can act as the basis for part of your final report, though of course it will need to be expanded and incorporated into the report. 7 PHAS0030 Mini-project briefing 5 Extensions There are many ways in which the basic simulations given so far could be extended, but here we suggest two, and give extra refer- ences to help implement these. You can of course choose your own extension, but you will need to find references and data yourself. Whichever direction you choose to extend the project, remember to concentrate on the physics that you are studying, and how the computational implementation enables insight into it. Your inves- tigation should of course include tests of the implementation, and could touch on the reliability of the method, but physics is most important here. 5.1 Solar system dynamics The orbital dynamics of the solar system are rich and varied, and provide a wealth of possible investigations. For instance, the eccen- tricity of the Moon’s orbit around the Earth has a periodic variation over approximately 18 years called the Saros cycle (a fact known to the Babylonians, but less well known these days); you should be able to observe this in a simulation of the Sun-Earth-Moon system, using the correct orbital parameters. You might instead (or as well) choose to simulate more of the solar system (all planets as far as Mars or Jupiter, or beyond), or investigate the effect of the larger asteroids on the orbit of Mars (Ceres, which is officially a dwarf planet, and Vesta, for instance). In order to successfully simulate the dynamics, you will need positions and velocities of the bodies you are simulating at a specific starting point. Fortunately, NASA publishes detailed ta- bles of ephemerides (positions and velocities of bodies in the solar system over time) which you can use for this purpose. I used Table 5 in the Planetary and Lunar Ephemerides DE430 and DE431[1] (there is a more up-to-date reference[2] but that does not contain tables). You can also use the JPL Horizons system (https://ssd.jpl.nasa.gov/horizons/app.html) though this may require a little experimentation to understand. You can of course use a less accurate approach, using known orbital periods and distances of the Sun-Earth-Moon system, along with the aver- age eccentricity, to estimate initial positions and velocities, adding the inclination of the Moon’s orbit (5.1◦) if you want; in the early stages I would advise doing this, starting without the inclination, to ensure that you are confident in the simulation. Once you are con- fident that it is working, you can add in the inclination, and turn to the exact positions and velocities if you wish. You will need to set up the appropriate constants and units (I would recommend working in SI units for simplicity, though whatever you choose, be sure to document it carefully). You should give careful thought to the timestep you will use, and the length of the simulation. 8 PHAS0030 Mini-project briefing One target for the Sun-Earth-Moon system could be to analyse your data to see if you can find the Saros cycle (seen in the variation of the eccentricity of the Moon’s orbit). The eccentricity of an orbit can be measured by the Laplace-Runge-Lenz-Pauli vector: L = rR rR − v2 RrR − (rR · vR)vR G(ME + MM) (8) where the subscript R means the relative Earth-Moon position or velocity. You may find it easiest to see the periodic variation if you plot the components of the eccentricity rather than the magnitude; you should also think about ways to analyse the eccentricity to find the frequencies (and hence the periods) of the variation (this potentially draws on material in Week 9 of the course, so might be best left to the end). From here, the direction you take is up to you, though you should be cautious and ensure that you identify a problem that you can solve in a sensible time. You should also think carefully about the goal of your simulations, and try to identify a clear re- search question. This does not need to be very grand (for instance, identifying cycles in the Moon’s eccentricity, and maybe their sensi- tivity to initial conditions, the integrator used or the time step) but should be scientifically meaningful. 5.2 N-body choreographies Another very interesting area where you could choose to extend your investigation is that of orbits of multiple bodies with the same mass. The oldest of these problems, for three bodies, was solved by Euler and Lagrange; the Lagrange solution consists of the three bodies arranged in an equilateral triangle (these are known as the Lagrange points in general—the L2 Lagrange point which comes from the solution of a slightly different problem is well-known as the site of the James Webb telescope). But there are more complex orbits which can be found, which have been labelled choreogra- phies, and they have been extended beyond three bodies as far as eight and beyond. The simplest example is for three bodies which all move in the same figure-of-eight pattern[3]. Patterns where all bodies follow the same path (though with different phases) are known as simple choreographies. It is relatively easy to work out the correct initial velocity for the simple Lagrange problem with three bodies evenly spaced around a circle, maintaining circular orbits. Once you have found this, you could explore the stability and shape of orbits which do not match this initial velocity: what orbits do they take on, and when are they stable? It is also perfectly possible to extend this problem to N bodies evenly spaced around a circle: does dependence of orbits on initial conditions (particularly stability of the orbits) change with number of bodies? If you want to investigate other simple choreographies, it is pos- 9 PHAS0030 Mini-project briefing sible to find initial conditions for braids (shapes which extend the figure of eight to more bodies). There is data for 3-body, 4-body and 6-body braids[4], though it requires a little work to understand. Table 5 of that paper gives the parameters ¯x and a for the four body braid; the definition of E(x1, ˙x0, ˙y1) (Eq 5.1) indicates how a and the components of ¯x can be mapped onto the necessary initial condi- tions for all particles. Similarly, Eq. 6.1 and Table 7 give parameters for the six body braid. The parameters for the three body braid (simple figure of eight) are also given in the paper: E(x0) is defined just above Remark 3.4, and the components of the velocity for the first body (the only necessary conditions) are given just below Ta- ble 1; note that these parameters are given to many decimal places deliberately. Going beyond these problems is likely to be highly non-trivial; if you can successfully implement the 3-, 4- and 6-body braids, you could investigate their long term stability (in some cases this is barely one period), or the sensitivity to initial conditions or propagator. You should also check conservation of energy and angular momentum. More recently, a large family of complex three body choreogra- phies (i.e. where the bodies follow different paths) have been discovered[5], with a more detailed discussion of the searching procedure available[6] (Table 2 in this second paper gives a set of stable orbits similar to the figure eight braid—this might form an interesting basis for investigation). It is also possible to find orbits with non-zero angular momentum[7], with a similar searching ap- proach (with footnote 13 giving initial conditions for an unusual three-body choreography). Note that these papers are quite ad- vanced, and you should not spend a long time trying to understand the detailed mathematics—they are mainly provided for the orbits they describe. These choreographies are very interesting, and it can be easy to be distracted creating appealing images of orbits. While meaningful representation of the orbit is important, you should always remem- ber to keep one eye on the physics of the investigation: what are you learning? What are you testing? It may be possible to also investigate an interesting system of gas giants described in a very recent Nature paper[8], though this could be very challenging indeed. In this system, the planets have orbital periods which are related by the ratios of small integers (e.g. 3/2), known as a Laplace resonant chain. It would be best to start by reproducing the system itself, using the periods (P) and orbital radii (ap) of the planets given in Table 1 of the paper, and then to expand your investigation. 6 Advice and suggestions Successful completion of a mini-project is challenging, and hope- fully also enjoyable. This gives you a taste of independent research, and your final report should be a formal scientific report. I provide 10 PHAS0030 Mini-project briefing advice and suggestions for your work on the mini-project based on several years of supervision and marking. • Build in complexity gradually: ensure that you understand what you have done in a given simulation before proceeding • Keep back-ups: in particular, if you have a working implementa- tion of a given problem which you are intending to change, keep a copy • Don’t be too ambitious: a well-documented, successful project will get better marks than an over-ambitious project that does not succeed • Be sure to work steadily throughout term: you cannot do a project like this well in a short time • Keep your log-book up-to-date • Follow the principles of academic integrity: ensure that all work presented is your own, or is properly referenced. Large language models and generative AI, such as ChatGPT, may not be used. • Note: As with the rest of this course, you must not use Python coding techniques or modules which have not been taught in the course. 7 Submission Your final submission should consist of a word-processed report (as a PDF file) and one or more log books (which are generally Jupyter notebooks). The report should be no more than 20 pages, and should be in the form of a scientific report or paper. You have freedom to choose how to write your report, but there are certain elements that should feature. You should provide an introduction to the topic, give an overview of the approach that you used (methods), present the results you found, and discuss their implications, and finish with a conclusion and a reference section. Your log books should clearly document how your code and the project has developed, including how you developed and tested your code, discuss how you have overcome problems you have en- countered, and show how your thoughts and ideas have developed; the work should all be dated clearly, to illustrate your progress through the project. Also note that you should be honest in the log books: seeing how you have overcome problems is an important part of the marking process. References [1] W. M. Folkner, J. G. Williams, D. H. Boggs, R. S. Park, and P. Kuchynka. The Planetary and Lunar Ephemerides DE430 and DE431. Interplanetary Network Progress Report, 42-196:1–81, 11 PHAS0030 Mini-project briefing February 2014. URL: https://naif.jpl.nasa.gov/pub/naif/ generic_kernels/spk/planets/de430_and_de431.pdf. [2] Ryan S. Park, William M. Folkner, James G. Williams, and Dale H. Boggs. The JPL Planetary and Lunar Ephemerides DE440 and DE441. The Astronomical Journal, 161(3):105, March 2021. URL: https://iopscience.iop.org/article/10.3847/ 1538-3881/abd414, doi:10.3847/1538-3881/abd414. [3] Alain Chenciner and Richard Montgomery. A remarkable periodic solution of the three-body problem in the case of equal masses. Annals of Mathematics, 152(3):881–901, 2000. URL: http://www.jstor.org/stable/2661357. [4] Tomasz Kapela and Piotr Zgliczynski. The existence of simple choreographies for the N-body problem—a computer-assisted proof. Nonlinearity, 16(6):1899–1918, November 2003. URL: https://iopscience.iop.org/article/10.1088/0951-7715/ 16/6/302, arXiv:math/0304404, doi:10.1088/0951-7715/16/6/ 302. [5] Milovan Šuvakov and V. Dmitrašinovi´c. Three classes of new- tonian three-body planar periodic orbits. Phys. Rev. Lett., 110:114301, Mar 2013. URL: https://link.aps.org/doi/10. 1103/PhysRevLett.110.114301, doi:10.1103/PhysRevLett. 110.114301. [6] Milovan Šuvakov and V. Dmitrašinovi´c. A guide to hunting periodic three-body orbits. American Jour- nal of Physics, 82(6):609–619, June 2014. URL: https: //pubs.aip.org/aapt/ajp/article/82/6/609/1057817/ A-guide-to-hunting-periodic-three-body-orbits, doi: 10.1119/1.4867608. [7] Marija R. Jankovi´c, V. Dmitrašinovi´c, and Milovan Šuvakov. A guide to hunting periodic three-body orbits with non- vanishing angular momentum. Computer Physics Com- munications, 250:107052, May 2020. URL: https://www. sciencedirect.com/science/article/pii/S0010465519303807, doi:10.1016/j.cpc.2019.107052. [8] R. Luque and et al. A resonant sextuplet of sub-neptunes tran- siting the bright star hd 110067. Nature, 623(7989):932–937, November 2023. URL: http://dx.doi.org/10.1038/ s41586-023-06692-3,https://arxiv.org/abs/2311.17775, doi:10.1038/s41586-023-06692-3. 12","libVersion":"0.5.0","langs":""}